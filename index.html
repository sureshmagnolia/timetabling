<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timetable Architect V4.3 (Interactive Deck)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes pulse-slow { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .move-cursor { cursor: crosshair !important; }
    </style>
</head>
<body class="bg-gray-50 text-slate-800 font-sans">
    <div id="root"></div>

    <script id="worker-script" type="javascript/worker">
        self.onmessage = function(e) {
            const { workload, classes, faculty, constraints, subjectLocks } = e.data;
            const DAYS = 5; const PERIODS = 5; 
            const schedule = {}; const teacherBusy = {}; 
            const stats = { iterations: 0, backtracks: 0, teacherConflicts: 0, roomConflicts: 0, dailyLimit: 0, lockConflicts: 0 };
            
            faculty.forEach(f => teacherBusy[f.id] = Array(DAYS).fill(null).map(() => Array(PERIODS + 1).fill(false)));
            classes.forEach(cls => {
                schedule[cls.id] = Array(DAYS).fill(null).map(() => Array(PERIODS + 1).fill(null));
                if (cls.unavailable) cls.unavailable.forEach(s => { const [d, p] = s.split('-').map(Number); if(schedule[cls.id][d]) schedule[cls.id][d][p] = { type: 'BLOCKED' }; });
            });

            // Prepare Tasks (Only those NOT already fixed in main thread)
            let tasks = [];
            workload.forEach(w => {
                // If manual lock exists, pre-fill it
                if(w.fixedDay !== undefined && w.fixedPeriod !== undefined) {
                    const d = parseInt(w.fixedDay);
                    const p = parseInt(w.fixedPeriod);
                    // Mark busy
                    if(schedule[w.classId] && schedule[w.classId][d]) {
                        schedule[w.classId][d][p] = { ...w, isFixed: true };
                        teacherBusy[w.teacherId][d][p] = true;
                        if(w.assistantId) teacherBusy[w.assistantId][d][p] = true;
                    }
                } else {
                    tasks.push({ ...w, uniqueId: w.id, isFixed: false });
                }
            });

            const teacherLoad = {};
            workload.forEach(w => teacherLoad[w.teacherId] = (teacherLoad[w.teacherId] || 0) + 1);
            tasks.sort((a, b) => {
                const isALocked = subjectLocks[`${a.classId}-Any-Any`] === a.subjectId; 
                const isBLocked = subjectLocks[`${b.classId}-Any-Any`] === b.subjectId;
                if (isALocked !== isBLocked) return isALocked ? -1 : 1;
                return (teacherLoad[b.teacherId]||0) - (teacherLoad[a.teacherId]||0);
            });

            const ALL_SLOTS = [];
            for(let d=0; d<DAYS; d++) for(let p=1; p<=PERIODS; p++) ALL_SLOTS.push({d, p});

            const isValid = (task, day, period) => {
                if (schedule[task.classId][day][period] !== null) { stats.roomConflicts++; return false; }
                if (teacherBusy[task.teacherId][day][period]) { stats.teacherConflicts++; return false; }
                if (task.assistantId && teacherBusy[task.assistantId][day][period]) { stats.teacherConflicts++; return false; }
                
                const lockKey = `${task.classId}-${day}-${period}`;
                const lockedSubjectId = subjectLocks[lockKey];
                if (lockedSubjectId && lockedSubjectId !== task.subjectId) { stats.lockConflicts++; return false; }
                
                let dailyCount = 0;
                for(let p=1; p<=PERIODS; p++) if(teacherBusy[task.teacherId][day][p]) dailyCount++;
                if (dailyCount >= constraints.maxDailyHours) { stats.dailyLimit++; return false; }
                
                return true;
            };

            let lastUpdate = Date.now();
            const startTime = Date.now();

            const solve = (taskIndex) => {
                stats.iterations++;
                if ((stats.iterations & 127) === 0) { 
                    const now = Date.now();
                    if (now - lastUpdate > 100) {
                        lastUpdate = now;
                        self.postMessage({ type: 'progress', current: taskIndex, total: tasks.length, stats, elapsed: ((now - startTime)/1000).toFixed(1) });
                    }
                }

                if (taskIndex >= tasks.length) return true;
                const task = tasks[taskIndex];

                const toggle = (d, p, val) => {
                    schedule[task.classId][d][p] = val ? task : null;
                    teacherBusy[task.teacherId][d][p] = val;
                    if(task.assistantId) teacherBusy[task.assistantId][d][p] = val;
                };

                const forcedSlots = [];
                if(Object.keys(subjectLocks).length > 0) {
                    for(let d=0; d<DAYS; d++) for(let p=1; p<=PERIODS; p++) 
                        if (subjectLocks[`${task.classId}-${d}-${p}`] === task.subjectId) forcedSlots.push({d, p});
                }

                let slotsToTry = (forcedSlots.length > 0) ? forcedSlots.filter(s => schedule[task.classId][s.d][s.p] === null) : ALL_SLOTS;
                
                for (let i = 0; i < slotsToTry.length; i++) {
                    const {d, p} = slotsToTry[i];
                    if (isValid(task, d, p)) {
                        toggle(d, p, true);
                        if (solve(taskIndex + 1)) return true;
                        toggle(d, p, false);
                    } else {
                        stats.backtracks++;
                    }
                }
                return false;
            };

            const success = solve(0);
            
            const assignments = [];
            Object.keys(schedule).forEach(clsId => {
                schedule[clsId].forEach((dayArr, d) => {
                    dayArr.forEach((slot, p) => {
                        if(slot && slot.type !== 'BLOCKED' && !slot.isFixed) {
                            assignments.push({ id: slot.uniqueId, d, p });
                        }
                    });
                });
            });

            self.postMessage({ type: 'done', success, assignments, stats });
        };
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { createRoot } = ReactDOM;
        const Icon = ({ name, className, onClick }) => <i data-lucide={name} className={className} onClick={onClick}></i>;

        const parseXMLData = (xmlText) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xmlText, "text/xml");
            const faculty = Array.from(doc.getElementsByTagName('teacher')).map(t => ({ id: t.getAttribute('id'), name: t.getAttribute('name'), short: t.getAttribute('short'), color: t.getAttribute('color') || '#e0f2f1' }));
            const subjects = Array.from(doc.getElementsByTagName('subject')).map(s => ({ id: s.getAttribute('id'), name: s.getAttribute('name'), code: s.getAttribute('short') || s.getAttribute('name').substring(0, 5) }));
            const classes = Array.from(doc.getElementsByTagName('class')).map(c => ({ id: c.getAttribute('id'), name: c.getAttribute('name'), short: c.getAttribute('short'), unavailable: [] }));
            const workload = [];
            Array.from(doc.getElementsByTagName('lesson')).forEach(l => {
                const tIds = l.getAttribute('teacherids').split(',');
                const cIds = l.getAttribute('classids').split(',');
                const subId = l.getAttribute('subjectid');
                const periods = parseFloat(l.getAttribute('periodsperweek') || l.getAttribute('periodspercard') || 1);
                cIds.forEach(cId => {
                    for(let i=0; i<periods; i++) {
                        workload.push({ id: l.getAttribute('id') + cId + i + Math.random().toString(36).substr(2, 5), classId: cId, subjectId: subId, teacherId: tIds[0], assistantId: tIds[1]||null, hoursPerWeek: 1 });
                    }
                });
            });
            return { faculty, subjects, classes, workload };
        };

        const TimetableApp = () => {
            const [subjectLocks, setSubjectLocks] = useState({});
            const [activeTab, setActiveTab] = useState('faculty');
            const [isGenerating, setIsGenerating] = useState(false);
            const [generationError, setGenerationError] = useState(null);
            const [saveStatus, setSaveStatus] = useState('');
            const fileInputRef = useRef(null);
            const workerRef = useRef(null);
            const [movingCard, setMovingCard] = useState(null);

            const [progress, setProgress] = useState({ current: 0, total: 0, stats: {}, elapsed: 0 });
            const [faculty, setFaculty] = useState([{ id: '1', name: 'Teacher A', short: 'TA', color: '#ffebee' }]);
            const [classes, setClasses] = useState([{ id: '1', name: 'Class 10A', short: '10A', unavailable: [] }]);
            const [subjects, setSubjects] = useState([{ id: '1', name: 'Math', code: 'MAT' }]);
            const [workload, setWorkload] = useState([]); 
            const [constraints, setConstraints] = useState({ maxConsecutive: 2, maxDailyHours: 4, ensureAllDaysEngaged: true });

            useEffect(() => {
                const saved = localStorage.getItem('tt_v9');
                if (saved) {
                    try {
                        const p = JSON.parse(saved);
                        if(p.faculty) setFaculty(p.faculty);
                        if(p.classes) setClasses(p.classes);
                        if(p.subjects) setSubjects(p.subjects);
                        if(p.workload) setWorkload(p.workload);
                        if(p.locks) setSubjectLocks(p.locks);
                    } catch(e) {}
                }
                if(window.lucide) window.lucide.createIcons();
            }, []);

            useEffect(() => {
                const t = setTimeout(() => {
                    localStorage.setItem('tt_v9', JSON.stringify({ faculty, classes, subjects, workload, locks: subjectLocks }));
                    setSaveStatus('Saved'); setTimeout(() => setSaveStatus(''), 2000);
                }, 1000);
                return () => clearTimeout(t);
            }, [faculty, classes, subjects, workload, subjectLocks]);

            useEffect(() => { if(window.lucide) window.lucide.createIcons(); });

            const checkPreConditions = () => {
                const errors = [];
                const roomMap = {};
                const teacherMap = {};
                workload.forEach(w => {
                    if (w.fixedDay !== undefined && w.fixedPeriod !== undefined) {
                        const rKey = `${w.classId}-${w.fixedDay}-${w.fixedPeriod}`;
                        const tKey = `${w.teacherId}-${w.fixedDay}-${w.fixedPeriod}`;
                        const tName = faculty.find(f=>f.id===w.teacherId)?.name;
                        const cName = classes.find(c=>c.id===w.classId)?.name;
                        if (roomMap[rKey]) errors.push(`Double Booking: ${cName} at Day ${parseInt(w.fixedDay)+1} P${w.fixedPeriod}`); else roomMap[rKey] = true;
                        if (teacherMap[tKey]) errors.push(`Conflict: ${tName} at Day ${parseInt(w.fixedDay)+1} P${w.fixedPeriod}`); else teacherMap[tKey] = true;
                    }
                });
                return errors;
            };

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    try {
                        const { faculty: f, subjects: s, classes: c, workload: w } = parseXMLData(evt.target.result);
                        setFaculty(f); setSubjects(s); setClasses(c); setWorkload(w);
                        alert(`Imported successfully!`);
                    } catch (err) { alert("Error parsing XML: " + err.message); }
                };
                reader.readAsText(file);
            };

            const handleGenerate = () => {
                if (checkPreConditions().length > 0) return alert("Please fix manual conflicts first.");
                setIsGenerating(true);
                setGenerationError(null);
                setActiveTab('results');
                setProgress({ current: 0, total: 0, stats: {}, elapsed: 0 });

                const blob = new Blob([document.getElementById('worker-script').textContent], { type: "text/javascript" });
                const worker = new Worker(URL.createObjectURL(blob));
                workerRef.current = worker;

                worker.onmessage = (e) => {
                    const { type, stats, assignments, success } = e.data;
                    if (type === 'progress') {
                        setProgress(e.data);
                    } else if (type === 'done') {
                        applyAutoAssignments(assignments);
                        setIsGenerating(false);
                        worker.terminate();
                        if(!success) alert("Finished with partial results.");
                    }
                };
                worker.postMessage({ workload, classes, faculty, constraints, subjectLocks });
            };

            const handleStop = () => {
                if (workerRef.current) workerRef.current.terminate();
                setIsGenerating(false);
            };

            const applyAutoAssignments = (assignments) => {
                if (!assignments) return;
                const newWorkload = workload.map(w => {
                    const match = assignments.find(a => a.id === w.id);
                    if (match) return { ...w, fixedDay: match.d, fixedPeriod: match.p };
                    if (!w.isManualLock) return { ...w, fixedDay: undefined, fixedPeriod: undefined }; 
                    return w; 
                });
                setWorkload(newWorkload);
            };

            const getFacultyLoad = (id) => workload.reduce((acc, w) => (w.teacherId === id || w.assistantId === id) ? acc + (w.hoursPerWeek||0) : acc, 0);

            // --- COMPONENTS ---
            const LoadingOverlay = () => (
                <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                    <div className="bg-white rounded-lg p-6 max-w-lg w-full shadow-2xl">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold flex items-center gap-2"><Icon name="cpu" className="animate-spin text-blue-600"/> Generating...</h2>
                            <button onClick={handleStop} className="text-xs bg-red-100 text-red-600 px-3 py-1 rounded border border-red-200 hover:bg-red-200 font-bold">STOP</button>
                        </div>
                        <div className="w-full bg-gray-200 rounded-full h-4 mb-2 overflow-hidden"><div className="bg-blue-600 h-4 rounded-full transition-all duration-300" style={{ width: `${(progress.current / (progress.total || 1)) * 100}%` }}></div></div>
                        <div className="text-xs text-center mt-2 text-gray-500">Wait for it to finish or click Stop to keep current.</div>
                    </div>
                </div>
            );

            const FacultyTab = () => {
                const [form, setForm] = useState({ name: '', short: '' });
                const handleSubmit = () => {
                    if(!form.name) return;
                    setFaculty([...faculty, { id: Date.now().toString(), ...form, color: '#f3f4f6' }]);
                    setForm({ name: '', short: '' });
                };
                return (
                    <div className="space-y-6">
                        <div className="bg-white p-6 rounded shadow border flex gap-2">
                            <input className="border p-2 rounded flex-1" placeholder="Name" value={form.name} onChange={e=>setForm({...form, name:e.target.value})} />
                            <input className="border p-2 rounded w-32" placeholder="Abbr" value={form.short} onChange={e=>setForm({...form, short:e.target.value})} />
                            <button onClick={handleSubmit} className="bg-blue-600 text-white px-4 rounded">Add</button>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            {faculty.map(f => (<div key={f.id} className="p-4 rounded shadow border bg-white flex justify-between"><div><div className="font-bold">{f.name}</div><div className="text-xs text-gray-500">Load: {getFacultyLoad(f.id)}</div></div><button onClick={()=>setFaculty(faculty.filter(x=>x.id!==f.id))} className="text-red-500"><Icon name="trash-2" className="w-4 h-4"/></button></div>))}
                        </div>
                    </div>
                );
            };

            const EntitiesTab = () => {
                const [classForm, setClassForm] = useState({ name: '', short: '' });
                const [subForm, setSubForm] = useState({ name: '', code: '' });
                return (
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <div className="space-y-4">
                            <div className="bg-white p-6 rounded shadow border flex gap-2"><input className="border p-2 rounded flex-1" placeholder="Class" value={classForm.name} onChange={e=>setClassForm({...classForm, name:e.target.value})} /><button onClick={()=>{if(classForm.name){setClasses([...classes, {id: Date.now().toString(), ...classForm, unavailable:[]}]); setClassForm({name:'', short:''})}}} className="bg-blue-600 text-white px-3 rounded">+</button></div>
                            <ul className="divide-y border rounded bg-gray-50">{classes.map(c=>(<li key={c.id} className="p-3 flex justify-between"><span>{c.name}</span><button onClick={()=>setClasses(classes.filter(x=>x.id!==c.id))} className="text-red-500"><Icon name="trash-2" className="w-4 h-4"/></button></li>))}</ul>
                        </div>
                        <div className="space-y-4">
                            <div className="bg-white p-6 rounded shadow border flex gap-2"><input className="border p-2 rounded flex-1" placeholder="Subject" value={subForm.name} onChange={e=>setSubForm({...subForm, name:e.target.value})} /><button onClick={()=>{if(subForm.name){setSubjects([...subjects, {id: Date.now().toString(), ...subForm}]); setSubForm({name:'', code:''})}}} className="bg-blue-600 text-white px-3 rounded">+</button></div>
                            <ul className="divide-y border rounded bg-gray-50">{subjects.map(s=>(<li key={s.id} className="p-3 flex justify-between"><span>{s.name}</span><button onClick={()=>setSubjects(subjects.filter(x=>x.id!==s.id))} className="text-red-500"><Icon name="trash-2" className="w-4 h-4"/></button></li>))}</ul>
                        </div>
                    </div>
                );
            };

            const WorkloadTab = () => {
                const [selClass, setSelClass] = useState(classes[0]?.id || '');
                const [form, setForm] = useState({ subId: '', teachId: '', count: 1 });
                const cw = workload.filter(w => w.classId == selClass);
                
                const addCards = () => {
                    if(!selClass || !form.subId || !form.teachId) return;
                    const newCards = [];
                    for(let i=0; i<form.count; i++) newCards.push({ id: Date.now().toString()+i, classId: selClass, subjectId: form.subId, teacherId: form.teachId, hoursPerWeek: 1 });
                    setWorkload([...workload, ...newCards]);
                };

                return (
                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div className="lg:col-span-1 space-y-4">
                            <div className="bg-white p-4 rounded shadow border space-y-3">
                                <div><label className="text-xs font-bold">Class</label><select className="border p-2 w-full rounded" value={selClass} onChange={e=>setSelClass(e.target.value)}>{classes.map(c=><option key={c.id} value={c.id}>{c.name}</option>)}</select></div>
                                <div><label className="text-xs font-bold">Subject</label><select className="border p-2 w-full rounded" value={form.subId} onChange={e=>setForm({...form, subId:e.target.value})}><option value="">Select</option>{subjects.map(s=><option key={s.id} value={s.id}>{s.name}</option>)}</select></div>
                                <div><label className="text-xs font-bold">Teacher</label><select className="border p-2 w-full rounded" value={form.teachId} onChange={e=>setForm({...form, teachId:e.target.value})}><option value="">Select</option>{faculty.map(f=><option key={f.id} value={f.id}>{f.name}</option>)}</select></div>
                                <div><label className="text-xs font-bold">Count</label><input type="number" className="border p-2 w-full rounded" value={form.count} onChange={e=>setForm({...form, count:parseInt(e.target.value)||1})}/></div>
                                <button onClick={addCards} className="w-full bg-green-600 text-white p-2 rounded font-bold">Add Cards</button>
                            </div>
                        </div>
                        <div className="lg:col-span-2">
                            <div className="bg-white rounded shadow border overflow-hidden">
                                <div className="bg-gray-100 p-3 font-bold border-b">Cards ({cw.length})</div>
                                <div className="p-4 grid grid-cols-2 md:grid-cols-4 gap-2">
                                    {cw.map(w => {
                                        const s = subjects.find(x=>x.id==w.subjectId);
                                        const t = faculty.find(x=>x.id==w.teacherId);
                                        return (
                                            <div key={w.id} className={`p-2 rounded border text-xs flex justify-between items-center ${w.fixedDay ? 'bg-green-50 border-green-200' : 'bg-white'}`}>
                                                <div><div className="font-bold">{s?.code}</div><div>{t?.short}</div></div>
                                                <button onClick={()=>setWorkload(workload.filter(x=>x.id!==w.id))} className="text-red-400 hover:text-red-600"><Icon name="trash-2" className="w-3 h-3"/></button>
                                            </div>
                                        )
                                    })}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            const ResultsTab = () => {
                const [selectedSlot, setSelectedSlot] = useState(null);

                const handleGridClick = (clsId, day, period) => {
                    if (movingCard) {
                        const cls = classes.find(c => c.id === clsId);
                        if (cls.unavailable.includes(`${day}-${period}`)) { alert("Slot blocked!"); return; }
                        
                        const card = workload.find(w => w.id === movingCard);
                        const conflict = workload.find(w => w.fixedDay == day && w.fixedPeriod == period && w.teacherId === card.teacherId && w.id !== card.id);
                        if(conflict) {
                            if(!confirm("Teacher conflict! Swap?")) return;
                            const updated = workload.map(w => {
                                if(w.id === conflict.id) return { ...w, fixedDay: undefined, fixedPeriod: undefined };
                                if(w.id === card.id) return { ...w, fixedDay: day, fixedPeriod: period, isManualLock: true };
                                return w;
                            });
                            setWorkload(updated);
                        } else {
                            const existing = workload.find(w => w.classId === clsId && w.fixedDay == day && w.fixedPeriod == period);
                            const updated = workload.map(w => {
                                if(existing && w.id === existing.id) return { ...w, fixedDay: undefined, fixedPeriod: undefined };
                                if(w.id === card.id) return { ...w, fixedDay: day, fixedPeriod: period, isManualLock: true };
                                return w;
                            });
                            setWorkload(updated);
                        }
                        setMovingCard(null); 
                    } else {
                        setSelectedSlot({ clsId, day, period });
                    }
                };

                const startMove = (cardId) => {
                    setMovingCard(cardId);
                    setSelectedSlot(null);
                };

                const handleAllocation = (type, payload) => {
                    const { clsId, day, period } = selectedSlot;
                    if (type === 'PLACE') {
                        const updated = workload.map(w => w.id === payload.id ? { ...w, fixedDay: day, fixedPeriod: period, isManualLock: true } : w);
                        setWorkload(updated);
                        setSelectedSlot(null);
                    }
                    else if (type === 'TO_DECK') {
                        const updated = workload.map(w => w.id === payload ? { ...w, fixedDay: undefined, fixedPeriod: undefined, isManualLock: false } : w);
                        setWorkload(updated);
                        setSelectedSlot(null);
                    }
                    else if (type === 'BLOCK') {
                        const key = `${day}-${period}`;
                        const newClasses = classes.map(c => {
                            if(c.id !== clsId) return c;
                            const isBlocked = c.unavailable.includes(key);
                            return { ...c, unavailable: isBlocked ? c.unavailable.filter(k => k !== key) : [...c.unavailable, key] };
                        });
                        setClasses(newClasses);
                        setSelectedSlot(null);
                    }
                };

                const Modal = () => {
                    if (!selectedSlot) return null;
                    const { clsId, day, period } = selectedSlot;
                    const cls = classes.find(c => c.id === clsId);
                    const isBlocked = cls.unavailable.includes(`${day}-${period}`);
                    
                    const current = workload.find(w => w.classId === clsId && w.fixedDay == day && w.fixedPeriod == period);
                    const deck = workload.filter(w => w.classId === clsId && w.fixedDay === undefined);

                    return (
                        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4" onClick={()=>setSelectedSlot(null)}>
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-sm overflow-hidden" onClick={e=>e.stopPropagation()}>
                                <div className="bg-slate-50 p-4 border-b">
                                    <h3 className="font-bold text-lg">{cls.name} <span className="text-sm font-normal text-gray-500">({day+1}-{period})</span></h3>
                                </div>
                                <div className="p-4 space-y-4 max-h-[60vh] overflow-y-auto">
                                    {isBlocked ? 
                                        <button onClick={()=>handleAllocation('BLOCK')} className="w-full bg-red-100 text-red-700 py-3 rounded font-bold">Unblock Slot</button> :
                                        current ? (
                                            <div className="space-y-2">
                                                <div className="p-3 border rounded bg-blue-50 border-blue-200">
                                                    <div className="font-bold">{subjects.find(s=>s.id==current.subjectId)?.name}</div>
                                                    <div className="text-xs text-gray-600">{faculty.find(f=>f.id==current.teacherId)?.name}</div>
                                                </div>
                                                <div className="grid grid-cols-2 gap-2">
                                                    <button onClick={()=>startMove(current.id)} className="bg-blue-600 text-white py-2 rounded text-xs font-bold">Move...</button>
                                                    <button onClick={()=>handleAllocation('TO_DECK', current.id)} className="bg-white border border-red-200 text-red-600 py-2 rounded text-xs font-bold">To Deck</button>
                                                </div>
                                            </div>
                                        ) : (
                                            <button onClick={()=>handleAllocation('BLOCK')} className="w-full border border-slate-300 text-slate-500 py-2 rounded text-xs hover:bg-slate-50">Block Slot</button>
                                        )
                                    }

                                    {!isBlocked && (
                                        <div className="pt-4 border-t">
                                            <div className="text-xs font-bold text-gray-400 uppercase mb-2">Pick from Deck</div>
                                            <div className="space-y-1">
                                                {deck.map(w => {
                                                    const s = subjects.find(x=>x.id==w.subjectId);
                                                    const t = faculty.find(f=>f.id==w.teacherId);
                                                    return (
                                                        <button key={w.id} onClick={()=>handleAllocation('PLACE', w)} className="w-full text-left p-2 rounded hover:bg-green-50 border border-transparent hover:border-green-200 flex justify-between items-center group">
                                                            <div><div className="font-bold text-sm">{s?.code}</div><div className="text-xs text-gray-500">{t?.short}</div></div>
                                                            <div className="text-green-600 opacity-0 group-hover:opacity-100 font-bold text-xs">Place</div>
                                                        </button>
                                                    )
                                                })}
                                                {deck.length === 0 && <div className="text-xs text-gray-400 text-center py-2">Empty Deck</div>}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    );
                };

                return (
                    <div className={`space-y-8 ${movingCard ? 'cursor-crosshair' : ''}`}>
                        {selectedSlot && <Modal />}
                        {movingCard && <div className="fixed top-20 left-1/2 -translate-x-1/2 bg-blue-600 text-white px-6 py-2 rounded-full shadow-xl z-50 animate-pulse font-bold flex items-center gap-2"><Icon name="move" className="w-4 h-4"/> Select destination slot... <button onClick={()=>setMovingCard(null)} className="ml-4 text-xs underline">Cancel</button></div>}
                        
                        <div className="flex justify-end sticky top-16 z-20"><button onClick={handleGenerate} className="bg-blue-600 text-white px-4 py-2 rounded shadow flex gap-2 items-center hover:bg-blue-700"><Icon name="play" className="w-4 h-4"/> Auto-Fill</button></div>
                        
                        {classes.map(cls => {
                            const unplaced = workload.filter(w => w.classId === cls.id && w.fixedDay === undefined);
                            return (
                                <div key={cls.id} className="bg-white rounded shadow border overflow-hidden">
                                    <div className="bg-gray-100 p-3 font-bold border-b flex justify-between items-center">
                                        <span>{cls.name}</span>
                                        <span className={`text-xs px-2 py-1 rounded ${unplaced.length > 0 ? 'bg-orange-100 text-orange-700' : 'bg-green-100 text-green-700'}`}>{unplaced.length} left</span>
                                    </div>
                                    <div className="overflow-x-auto"><table className="w-full text-center text-sm border-collapse table-fixed">
                                        <thead><tr><th className="border p-2 w-16 bg-slate-50"></th>{[1,2,3,4,5].map(p=><th key={p} className="border p-2 bg-slate-50">P{p}</th>)}</tr></thead>
                                        <tbody>{["M","T","W","T","F"].map((d,i)=><tr key={i}><td className="border p-2 font-bold bg-slate-50">{d}</td>{[1,2,3,4,5].map(p=>{
                                            const isBlocked = cls.unavailable.includes(`${i}-${p}`);
                                            const card = workload.find(w => w.classId === cls.id && w.fixedDay == i && w.fixedPeriod == p);
                                            let content = null;
                                            let style = "hover:bg-slate-50";
                                            if(isBlocked) { content = "âŒ"; style = "bg-red-50"; }
                                            else if(card) {
                                                const s = subjects.find(x=>x.id==card.subjectId);
                                                const t = faculty.find(f=>f.id==card.teacherId);
                                                content = <div><div className="font-bold">{s?.code}</div><div className="text-[10px] text-gray-500">{t?.short}</div></div>;
                                                style = "bg-blue-50 border-blue-200 hover:bg-blue-100";
                                            }
                                            return <td key={p} onClick={()=>handleGridClick(cls.id, i, p)} className={`border p-1 h-16 transition-colors cursor-pointer ${style}`}>{content}</td>
                                        })}</tr>)}</tbody>
                                    </table></div>
                                    <div className="bg-slate-50 p-3 border-t">
                                        <div className="text-xs font-bold text-slate-400 uppercase mb-2">Unplaced Deck (Click to Place)</div>
                                        <div className="flex flex-wrap gap-2">
                                            {unplaced.map(w => {
                                                const s = subjects.find(x=>x.id==w.subjectId);
                                                const t = faculty.find(x=>x.id==w.teacherId);
                                                return <button key={w.id} onClick={(e)=>{e.stopPropagation(); startMove(w.id)}} className="bg-white border border-slate-300 text-slate-600 px-2 py-1 rounded text-xs shadow-sm hover:border-blue-500 hover:text-blue-600"><strong>{s?.code}</strong> ({t?.short})</button>
                                            })}
                                            {unplaced.length === 0 && <span className="text-green-600 text-xs font-bold">Empty</span>}
                                        </div>
                                    </div>
                                </div>
                            )
                        })}
                    </div>
                );
            };

            return (
                <div className="min-h-screen pb-20">
                    <div className="bg-white border-b sticky top-0 z-10 px-4 h-16 flex items-center justify-between shadow-sm">
                        <h1 className="font-bold text-xl flex items-center gap-2"><Icon name="calendar" /> Timetable Architect V4.3</h1>
                        <div className="flex gap-4 items-center">
                            <span className={`text-xs font-bold text-green-600 transition-opacity ${saveStatus?'opacity-100':'opacity-0'}`}>Saved</span>
                            <div className="relative overflow-hidden"><button className="text-xs bg-slate-100 px-3 py-1 rounded hover:bg-slate-200 border flex gap-1 items-center"><Icon name="upload" className="w-3 h-3"/> Import XML</button><input type="file" ref={fileInputRef} onChange={handleFileUpload} className="absolute inset-0 opacity-0 cursor-pointer" accept=".xml"/></div>
                        </div>
                    </div>
                    {isGenerating && <LoadingOverlay />}
                    <div className="px-4 mt-2 overflow-x-auto"><div className="flex space-x-1 border-b">{['faculty','entities','workload','constraints','results'].map(t=><button key={t} onClick={()=>setActiveTab(t)} className={`px-4 py-2 capitalize border-b-2 ${activeTab===t?'border-blue-600 text-blue-600':'border-transparent text-gray-500'}`}>{t}</button>)}</div></div>
                    <div className="max-w-6xl mx-auto p-4">{activeTab==='faculty'&&<FacultyTab/>}{activeTab==='entities'&&<EntitiesTab/>}{activeTab==='workload'&&<WorkloadTab/>}{activeTab==='constraints'&&<ConstraintsTab/>}{activeTab==='results'&&<ResultsTab/>}</div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<TimetableApp />);
    </script>
</body>
</html>
